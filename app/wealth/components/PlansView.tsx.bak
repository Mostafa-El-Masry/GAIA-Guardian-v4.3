"use client";

import { Plan, FinancialMetrics, PLANS } from "../lib/wealthLevels";
import {
  determineActivePlan,
  calculatePlanProgress,
  determineWealthLevel,
  principalForMonthlyPayout,
  simulateMonthsToMonthlyInterest,
} from "../lib/calculations";
import { loadSettings, saveSettings } from "../lib/persistence";
import { loadNetItems } from "../lib/store";

interface PlansViewProps {
  metrics: FinancialMetrics;
}

// Helper function to format months display
function monthsDisplay(m: number | null): string {
  if (m == null || !isFinite(m) || m <= 0) return "—";
  if (m >= 1200) return "Not reachable";
  if (m > 600) return "600+";
  return String(Math.round(m));
}

export function PlansView({ metrics }: PlansViewProps) {
  // Load settings directly (component-level); WealthLevels also persists settings
  const settings = loadSettings();

  const startPrincipalEGP =
    settings.startingPrincipalEgp && settings.startingPrincipalEgp > 0
      ? settings.startingPrincipalEgp
      : inferredPrincipalFromNet;

  // Plan D (primary certificates target)
  const planDTargetEGP = settings.planDTargetMonthlyEgp;
  const planDTargetPrincipalEGP = principalForMonthlyPayout(
    planDTargetEGP,
    currentAprDecimal
  );

  // Calculate total monthly interest from all active certificates
  const planDCurrentMonthlyInterest = (() => {
    try {
      const items = loadNetItems();
      const certItems = items.filter(
        (i) => i.isCertificate && i.monthlyRevenue
      );
      const total = certItems.reduce(
        (sum, i) => sum + (i.monthlyRevenue || 0),
        0
      );
      return total;
    } catch (e) {
      return 0;
    }
  })();

  const planDProgressPct = Math.min(
    100,
    (planDCurrentMonthlyInterest / planDTargetEGP) * 100
  );
  const reinvestFraction = settings.reinvest
    ? (settings.reinvestPercent ?? 100) / 100
    : 0;

  // Perform simulation for Plan D with validation
  const planDSim = (() => {
    if (!isFinite(startPrincipalEGP) || startPrincipalEGP < 0)
      return { months: null, principal: 0, monthlyInterest: 0 };
    if (!isFinite(monthlyEgpContribution) || monthlyEgpContribution < 0)
      return { months: null, principal: 0, monthlyInterest: 0 };
    if (!isFinite(currentAprDecimal) || currentAprDecimal <= 0)
      return { months: null, principal: 0, monthlyInterest: 0 };
    if (!isFinite(planDTargetEGP) || planDTargetEGP <= 0)
      return { months: null, principal: 0, monthlyInterest: 0 };

    return simulateMonthsToMonthlyInterest(
      startPrincipalEGP,
      monthlyEgpContribution,
      currentAprDecimal,
      planDTargetEGP,
      reinvestFraction
    );
  })();

  // Plan C
  const planCTargetEGP = settings.planCTargetMonthlyEgp ?? 10000;
  const planCTargetPrincipalEGP = principalForMonthlyPayout(
    planCTargetEGP,
    currentAprDecimal
  );
  const planCCurrentMonthlyInterest =
    startPrincipalEGP * (currentAprDecimal / 12);
  const planCProgressPct = Math.min(
    100,
    (planCCurrentMonthlyInterest / planCTargetEGP) * 100
  );
  const planCSim = simulateMonthsToMonthlyInterest(
    startPrincipalEGP,
    monthlyEgpContribution,
    currentAprDecimal,
    planCTargetEGP,
    reinvestFraction
  );

  // Plan B
  const planBCertificateTargetEGP = Math.max(
    1,
    Math.round(monthlyExpensesKD * settings.fxEgpPerKd)
  );
  const planBTargetPrincipalEGP = principalForMonthlyPayout(
    planBCertificateTargetEGP,
    currentAprDecimal
  );
  const planBCurrentMonthlyInterest =
    startPrincipalEGP * (currentAprDecimal / 12);
  const planBProgressPct = Math.min(
    100,
    (planBCurrentMonthlyInterest / planBCertificateTargetEGP) * 100
  );
  const planBSim = simulateMonthsToMonthlyInterest(
    startPrincipalEGP,
    monthlyEgpContribution,
    currentAprDecimal,
    planBCertificateTargetEGP,
    reinvestFraction
  );

  // Plan A
  const planACertificateTargetEGP =
    1.5 * monthlyExpensesKD * settings.fxEgpPerKd;
  const planATargetPrincipalEGP = principalForMonthlyPayout(
    planACertificateTargetEGP,
    currentAprDecimal
  );
  const planACurrentMonthlyInterest =
    startPrincipalEGP * (currentAprDecimal / 12);
  const planAProgressPct = Math.min(
    100,
    (planACurrentMonthlyInterest / planACertificateTargetEGP) * 100
  );
  const planASim = simulateMonthsToMonthlyInterest(
    startPrincipalEGP,
    monthlyEgpContribution,
    currentAprDecimal,
    planACertificateTargetEGP,
    reinvestFraction
  );

  const planDisplays = [
    {
      type: "D" as const,
      title: "Catching my Breath",
      objective: PLANS.D.objective,
      targetMonthlyEGP: planDTargetEGP,
      targetPrincipalEGP: planDTargetPrincipalEGP,
      currentMonthlyInterestEGP: planDCurrentMonthlyInterest,
      progressPct: planDProgressPct,
      monthsToTarget: planDSim.months ?? null,
      estimatedPrincipal:
        planDSim.principal > 0 ? Math.round(planDSim.principal) : null,
      isComplete: planDCurrentMonthlyInterest >= planDTargetEGP,
    },
    {
      type: "C" as const,
      title: "Stabilize",
      objective: PLANS.C.objective,
      targetMonthlyEGP: planCTargetEGP,
      targetPrincipalEGP: planCTargetPrincipalEGP,
      currentMonthlyInterestEGP: planCCurrentMonthlyInterest,
      progressPct: planCProgressPct,
      monthsToTarget: planCSim.months,
      isComplete: planCCurrentMonthlyInterest >= planCTargetEGP,
    },
    {
      type: "B" as const,
      title: "Secure",
      objective: PLANS.B.objective,
      targetMonthlyEGP: planBCertificateTargetEGP,
      targetPrincipalEGP: planBTargetPrincipalEGP,
      currentMonthlyInterestEGP: planBCurrentMonthlyInterest,
      progressPct: planBProgressPct,
      monthsToTarget: planBSim.months,
      estimatedPrincipal: Math.round(planBSim.principal),
      isComplete: planBCurrentMonthlyInterest >= planBCertificateTargetEGP,
    },
    {
      type: "A" as const,
      title: "Grow",
      objective: PLANS.A.objective,
      targetMonthlyEGP: planACertificateTargetEGP,
      targetPrincipalEGP: planATargetPrincipalEGP,
      currentMonthlyInterestEGP: planACurrentMonthlyInterest,
      progressPct: planAProgressPct,
      monthsToTarget: planASim.months,
      estimatedPrincipal: Math.round(planASim.principal),
      isComplete: planACurrentMonthlyInterest >= planACertificateTargetEGP,
    },
  ];

  const order: ("D" | "C" | "B" | "A")[] = ["D", "C", "B", "A"];
  let activePlan = settings.activePlan ?? "D";

  const activeDisplay = planDisplays.find((p) => p.type === activePlan);
  if (activeDisplay && activeDisplay.isComplete) {
    const idx = order.indexOf(activePlan);
    const next = order
      .slice(idx + 1)
      .find((t) => !planDisplays.find((p) => p.type === t)?.isComplete);
    if (next) {
      settings.activePlan = next;
      saveSettings(settings);
      activePlan = next;
    }
  }

  return (
    <div className="space-y-6">
      {planDisplays.map((p) => {
        const isActive = settings.activePlan === p.type;
        return (
          <div
            key={p.type}
            aria-current={isActive ? "true" : undefined}
            className={`p-6 rounded-lg border transition-shadow duration-200 ${
              isActive
                ? "border-primary bg-primary/6 shadow-lg ring-1 ring-primary/20"
                : p.isComplete
                ? "border-green-300 bg-green-50"
                : "border-muted bg-card"
            }`}
          >
            {p.type !== "D" && (
              <div className="mb-3 text-xs text-muted-foreground">
                Your savings from Plan D continue to carry forward into this
                plan.
              </div>
            )}
            <div className="flex items-center justify-between mb-4">
              <div>
                <h3 className="text-lg font-medium flex items-center gap-2">{`Plan ${p.type} · ${p.title}`}</h3>
                {isActive && (
                  <div className="mt-1 text-sm px-3 py-1 rounded-full bg-primary text-primary-foreground inline-block shadow-sm">
                    Active plan
                  </div>
                )}
                <p className="text-sm text-muted-foreground mt-1">
                  {p.objective}
                </p>
              </div>
              {p.isComplete && (
                <div className="text-green-600 flex items-center gap-1">
                  <span>✓</span>
                  <span className="text-sm font-medium">Complete</span>
                </div>
              )}
            </div>

            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm text-muted-foreground">Progress</div>
                <div className="text-sm font-medium">
                  {Math.round(p.progressPct)}%
                </div>
              </div>
              <div className="h-2 bg-secondary rounded-full overflow-hidden">
                <div
                  className={`h-full transition-all duration-500 ${
                    p.isComplete ? "bg-green-500" : "bg-primary"
                  }`}
                  style={{ width: `${Math.min(100, p.progressPct)}%` }}
                />
              </div>
            </div>

            <div className="mt-4 space-y-2 text-sm">
              <div>
                <span className="text-muted-foreground">Current APR: </span>
                <span className="font-medium">{currentAprPercent}%</span>
              </div>
              <div>
                <span className="text-muted-foreground">
                  Target monthly income (EGP):{" "}
                </span>
                <span className="font-medium">
                  {Math.round(p.targetMonthlyEGP).toLocaleString()} EGP
                </span>
              </div>
              <div className="pl-4 border-l-2 border-muted my-2">
                <div className="text-muted-foreground text-xs mb-1">
                  Target principal calculation:
                </div>
                <div className="font-mono text-xs space-y-1">
                  {currentAprPercent > 0 ? (
                    <>
                      <div>Monthly income × (12 / APR)</div>
                      <div>
                        {Math.round(p.targetMonthlyEGP).toLocaleString()} × (12
                        / {currentAprPercent}%) =
                      </div>
                      <div className="font-medium text-sm">
                        {Math.round(p.targetPrincipalEGP).toLocaleString()} EGP
                        required investment
                      </div>
                    </>
                  ) : (
                    <div className="text-muted-foreground">
                      Please set an APR to calculate required investment
                    </div>
                  )}
                </div>
              </div>
              <div>
                <span className="text-muted-foreground">
                  Current monthly interest (EGP):{" "}
                </span>
                <span className="font-medium">
                  {Math.round(p.currentMonthlyInterestEGP).toLocaleString()} EGP
                </span>
              </div>
              {p.monthsToTarget != null && (
                <div className="pt-2 border-t gaia-border">
                  <div>
                    <span className="text-muted-foreground">
                      Monthly deposit (EGP):{" "}
                    </span>
                    <span className="font-medium">
                      {Math.round(monthlyEgpContribution).toLocaleString()} EGP
                    </span>
                  </div>
                  <div>
                    <span className="text-muted-foreground">
                      Est. months to target: {" "}
                    </span>
                    <span className="font-medium">
                      {monthsDisplay(p.monthsToTarget)}
                    </span>
                  </div>
                  <div>
                    <span className="text-muted-foreground">
                      Est. final principal: {" "}
                    </span>
                    <span className="font-medium">
                      {(() => {
                        const sim =
                          p.type === "D"
                            ? planDSim
                            : p.type === "C"
                            ? planCSim
                            : p.type === "B"
                            ? planBSim
                            : planASim;
                        const finalPrincipal = sim?.principal;
                        return !finalPrincipal || !isFinite(finalPrincipal)
                          ? "—"
                          : Math.round(finalPrincipal).toLocaleString() +
                              " EGP";
                      })()}
                    </span>
                  </div>
                </div>
              )}
            </div>

            <div className="mt-4 p-3 rounded-md border gaia-border bg-[color-mix(in_srgb,var(--gaia-surface)_88%,transparent)]">
              <div className="text-sm mb-2">Simulator (quick):</div>
              <div className="grid grid-cols-1 sm:grid-cols-4 gap-2 text-sm">
                <div>
                  <div className="text-muted-foreground">Monthly deposit</div>
                  <div className="font-medium">
                    {Math.round(monthlyEgpContribution).toLocaleString()} EGP
                  </div>
                </div>
                <div>
                  <div className="text-muted-foreground">Current APR</div>
                  <div className="font-medium">{currentAprPercent}%</div>
                </div>
                <div>
                  <div className="text-muted-foreground">Est. months</div>
                  <div className="font-medium">{monthsDisplay(p.monthsToTarget)}</div>
                </div>
                <div>
                  <div className="text-muted-foreground">Est. principal</div>
                  <div className="font-medium">
                    {!p.estimatedPrincipal || !isFinite(p.estimatedPrincipal)
                      ? "—"
                      : Math.round(p.estimatedPrincipal).toLocaleString() +
                        " EGP"}
                  </div>
                </div>
              </div>
              <div className="mt-3 flex items-center gap-2">
                <button
                  className="px-3 py-1 rounded border gaia-border gaia-surface text-sm"
                  onClick={() => {
                    document
                      .getElementById("savings-simulator")
                      ?.scrollIntoView({ behavior: "smooth", block: "start" });
                  }}
                >
                  Open full simulator
                </button>
                <div className="text-xs text-muted-foreground">
                  Opens the full simulator below; adjust deposit values there.
                </div>
              </div>
            </div>
          </div>
        );
      })}
    </div>
  );
}
import { Plan, FinancialMetrics, PLANS } from "../lib/wealthLevels";
import {
  determineActivePlan,
  calculatePlanProgress,
  determineWealthLevel,
  principalForMonthlyPayout,
  simulateMonthsToMonthlyInterest,
} from "../lib/calculations";
import { loadSettings, saveSettings } from "../lib/persistence";
import { loadNetItems } from "../lib/store";

interface PlansViewProps {
  metrics: FinancialMetrics;
}

export function PlansView({ metrics }: PlansViewProps) {
  // Load settings directly (component-level); WealthLevels also persists settings
  const settings = loadSettings();

  const monthlyExpensesKD = settings.expenses.reduce(
    (s, e) => s + e.amountKD,
    0
  );
  const monthlySurplusKD = Math.max(
    0,
    settings.monthlyIncomeKD - monthlyExpensesKD
  );
  const monthlyEgpContribution = monthlySurplusKD * settings.fxEgpPerKd;

  const aprSchedule = settings.aprSchedule;
  const currentAprPercent =
    aprSchedule[0]?.aprPercent ??
    aprSchedule[aprSchedule.length - 1]?.aprPercent ??
    0;
  const currentAprDecimal = currentAprPercent / 100;

  // Try to infer starting principal from Net Items (sum of items whose name implies certificates)
  const inferredPrincipalFromNet = (() => {
    try {
      const items = loadNetItems();
      console.log("Net items in PlansView:", items);
      const re = /cert|certificate|cd|cdu|deposit/i;
      const filtered = items.filter((i) => i.amount > 0 && re.test(i.name));
      console.log("Filtered certificate items:", filtered);
      const total = filtered.reduce((s, i) => s + i.amount, 0);
      console.log("Total principal:", total);
      return total;
    } catch (e) {
      console.error("Error in inferredPrincipalFromNet:", e);
      return 0;
    }
  })();

  const startPrincipalEGP =
    settings.startingPrincipalEgp && settings.startingPrincipalEgp > 0
      ? settings.startingPrincipalEgp
      : inferredPrincipalFromNet;

  // Plan D (primary certificates target)
  const planDTargetEGP = settings.planDTargetMonthlyEgp;
  const planDTargetPrincipalEGP = principalForMonthlyPayout(
    planDTargetEGP,
    currentAprDecimal
  );
  // Calculate total monthly interest from all active certificates
  const planDCurrentMonthlyInterest = (() => {
    try {
      const items = loadNetItems();
      console.log("Checking monthly interest - all items:", items);
      const certItems = items.filter(
        (i) => i.isCertificate && i.monthlyRevenue
      );
      console.log("Certificate items with monthly revenue:", certItems);
      const total = certItems.reduce(
        (sum, i) => sum + (i.monthlyRevenue || 0),
        0
      );
      console.log("Total monthly interest:", total);
      return total;
    } catch (e) {
      console.error("Error calculating monthly interest:", e);
      return 0;
    }
  })();
  console.log("Plan D Current State:", {
    targetMonthlyEGP: planDTargetEGP,
    currentMonthlyInterest: planDCurrentMonthlyInterest,
    targetPrincipalEGP: planDTargetPrincipalEGP,
    startPrincipalEGP,
    monthlyEgpContribution,
    currentAprDecimal,
  });
  const planDProgressPct = Math.min(
    100,
    (planDCurrentMonthlyInterest / planDTargetEGP) * 100
  );
  const reinvestFraction = settings.reinvest
    ? (settings.reinvestPercent ?? 100) / 100
    : 0;
  console.log("Simulation inputs:", {
    startPrincipalEGP,
    monthlyEgpContribution,
    currentAprDecimal,
    planDTargetEGP,
    reinvestFraction,
  });
  // Perform simulation for Plan D with validation
  const planDSim = (() => {
    // Validate inputs
    if (!isFinite(startPrincipalEGP) || startPrincipalEGP < 0) {
      console.error("Invalid starting principal:", startPrincipalEGP);
      return { months: null, principal: 0, monthlyInterest: 0 };
    }
    if (!isFinite(monthlyEgpContribution) || monthlyEgpContribution < 0) {
      console.error("Invalid monthly contribution:", monthlyEgpContribution);
      return { months: null, principal: 0, monthlyInterest: 0 };
    }
    if (!isFinite(currentAprDecimal) || currentAprDecimal <= 0) {
      console.error("Invalid APR:", currentAprDecimal);
      return { months: null, principal: 0, monthlyInterest: 0 };
    }
    if (!isFinite(planDTargetEGP) || planDTargetEGP <= 0) {
      console.error("Invalid target monthly interest:", planDTargetEGP);
      return { months: null, principal: 0, monthlyInterest: 0 };
    }

    const sim = simulateMonthsToMonthlyInterest(
      startPrincipalEGP,
      monthlyEgpContribution,
      currentAprDecimal,
      planDTargetEGP,
      reinvestFraction
    );

    console.log("Plan D Simulation Result:", sim);
    return sim;
  })();
  console.log("Simulation result:", planDSim);

  // Plan C: stabilize (L5 buffer) + certificate income target (defaults to settings.planCTargetMonthlyEgp)
  const planCTargetEGP = settings.planCTargetMonthlyEgp ?? 10000;
  const planCTargetPrincipalEGP = principalForMonthlyPayout(
    planCTargetEGP,
    currentAprDecimal
  );
  const planCCurrentMonthlyInterest =
    startPrincipalEGP * (currentAprDecimal / 12);
  const planCProgressPct = Math.min(
    100,
    (planCCurrentMonthlyInterest / planCTargetEGP) * 100
  );
  const planCSim = simulateMonthsToMonthlyInterest(
    startPrincipalEGP,
    monthlyEgpContribution,
    currentAprDecimal,
    planCTargetEGP,
    reinvestFraction
  );

  // Plan B: buffer 12x expenses + certificate income covers baseline KD expenses
  const planBBufferKD = 12 * monthlyExpensesKD;
  const planBCertificateTargetEGP = Math.max(
    1,
    Math.round(monthlyExpensesKD * settings.fxEgpPerKd)
  );
  const planBTargetPrincipalEGP = principalForMonthlyPayout(
    planBCertificateTargetEGP,
    currentAprDecimal
  );
  const planBCurrentMonthlyInterest =
    startPrincipalEGP * (currentAprDecimal / 12);
  const planBProgressPct = Math.min(
    100,
    (planBCurrentMonthlyInterest / planBCertificateTargetEGP) * 100
  );

  const planBSim = simulateMonthsToMonthlyInterest(
    startPrincipalEGP,
    monthlyEgpContribution,
    currentAprDecimal,
    planBCertificateTargetEGP,
    reinvestFraction
  );

  // Plan A: L9 (60× expenses) and passive certificate income ≥ 1.5× baseline expenses
  const planABufferKD = 60 * monthlyExpensesKD;
  const planACertificateTargetEGP =
    1.5 * monthlyExpensesKD * settings.fxEgpPerKd;
  const planATargetPrincipalEGP = principalForMonthlyPayout(
    planACertificateTargetEGP,
    currentAprDecimal
  );
  const planACurrentMonthlyInterest =
    startPrincipalEGP * (currentAprDecimal / 12);
  const planAProgressPct = Math.min(
    100,
    (planACurrentMonthlyInterest / planACertificateTargetEGP) * 100
  );
  const planASim = simulateMonthsToMonthlyInterest(
    startPrincipalEGP,
    monthlyEgpContribution,
    currentAprDecimal,
    planACertificateTargetEGP,
    reinvestFraction
  );

  // Build plan display objects (only a subset of fields used by PLANS)
  const planDisplays = [
    {
      type: "D" as const,
      title: "Catching my Breath",
      objective: PLANS.D.objective,
      targetMonthlyEGP: planDTargetEGP,
      targetPrincipalEGP: planDTargetPrincipalEGP,
      currentMonthlyInterestEGP: planDCurrentMonthlyInterest,
      progressPct: planDProgressPct,
      monthsToTarget: planDSim.months ?? null,
      estimatedPrincipal:
        planDSim.principal > 0 ? Math.round(planDSim.principal) : null,
      isComplete: planDCurrentMonthlyInterest >= planDTargetEGP,
    },
    {
      type: "C" as const,
      title: "Stabilize",
      objective: PLANS.C.objective,
      targetMonthlyEGP: planCTargetEGP,
      targetPrincipalEGP: planCTargetPrincipalEGP,
      currentMonthlyInterestEGP: planCCurrentMonthlyInterest,
      progressPct: planCProgressPct,
      monthsToTarget: planCSim.months,
      isComplete: planCCurrentMonthlyInterest >= planCTargetEGP,
    },
    {
      type: "B" as const,
      title: "Secure",
      objective: PLANS.B.objective,
      targetMonthlyEGP: planBCertificateTargetEGP,
      targetPrincipalEGP: planBTargetPrincipalEGP,
      currentMonthlyInterestEGP: planBCurrentMonthlyInterest,
      progressPct: planBProgressPct,
      monthsToTarget: planBSim.months,
      estimatedPrincipal: Math.round(planBSim.principal),
      isComplete: planBCurrentMonthlyInterest >= planBCertificateTargetEGP,
    },
    {
      type: "A" as const,
      title: "Grow",
      objective: PLANS.A.objective,
      targetMonthlyEGP: planACertificateTargetEGP,
      targetPrincipalEGP: planATargetPrincipalEGP,
      currentMonthlyInterestEGP: planACurrentMonthlyInterest,
      progressPct: planAProgressPct,
      monthsToTarget: planASim.months,
      estimatedPrincipal: Math.round(planASim.principal),
      isComplete: planACurrentMonthlyInterest >= planACertificateTargetEGP,
    },
  ];
  // Determine active plan (persisted) and auto-advance if needed
  const order: ("D" | "C" | "B" | "A")[] = ["D", "C", "B", "A"];
  let activePlan = settings.activePlan ?? "D";

  // If the current active plan is complete, advance to the next incomplete plan
  const activeDisplay = planDisplays.find((p) => p.type === activePlan);
  if (activeDisplay && activeDisplay.isComplete) {
    const idx = order.indexOf(activePlan);
    const next = order
      .slice(idx + 1)
      .find((t) => !planDisplays.find((p) => p.type === t)?.isComplete);
    if (next) {
      // persist active plan
      settings.activePlan = next;
      saveSettings(settings);
      activePlan = next;
    }
  }

  return (
    <div className="space-y-6">
      {planDisplays.map((p) => {
        const isActive = settings.activePlan === p.type;
        return (
          <div
            key={p.type}
            aria-current={isActive ? "true" : undefined}
            className={`p-6 rounded-lg border transition-shadow duration-200 ${
              isActive
                ? "border-primary bg-primary/6 shadow-lg ring-1 ring-primary/20"
                : p.isComplete
                ? "border-green-300 bg-green-50"
                : "border-muted bg-card"
            }`}
          >
            {/* carry-forward ribbon for plans beyond D */}
            {p.type !== "D" && (
              <div className="mb-3 text-xs text-muted-foreground">
                Your savings from Plan D continue to carry forward into this
                plan.
              </div>
            )}
            <div className="flex items-center justify-between mb-4">
              <div>
                <h3 className="text-lg font-medium flex items-center gap-2">{`Plan ${p.type} · ${p.title}`}</h3>
                {isActive && (
                  <div className="mt-1 text-sm px-3 py-1 rounded-full bg-primary text-primary-foreground inline-block shadow-sm">
                    Active plan
                  </div>
                )}
                <p className="text-sm text-muted-foreground mt-1">
                  {p.objective}
                </p>
              </div>
              {p.isComplete && (
                <div className="text-green-600 flex items-center gap-1">
                  <span>✓</span>
                  <span className="text-sm font-medium">Complete</span>
                </div>
              )}
            </div>

            <div>
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm text-muted-foreground">Progress</div>
                <div className="text-sm font-medium">
                  {Math.round(p.progressPct)}%
                </div>
              </div>
              <div className="h-2 bg-secondary rounded-full overflow-hidden">
                <div
                  className={`h-full transition-all duration-500 ${
                    p.isComplete ? "bg-green-500" : "bg-primary"
                  }`}
                  style={{ width: `${Math.min(100, p.progressPct)}%` }}
                />
              </div>
            </div>

            <div className="mt-4 space-y-2 text-sm">
              <div>
                <span className="text-muted-foreground">Current APR: </span>
                <span className="font-medium">{currentAprPercent}%</span>
              </div>
              <div>
                <span className="text-muted-foreground">
                  Target monthly income (EGP):{" "}
                </span>
                <span className="font-medium">
                  {Math.round(p.targetMonthlyEGP).toLocaleString()} EGP
                </span>
              </div>
              <div className="pl-4 border-l-2 border-muted my-2">
                <div className="text-muted-foreground text-xs mb-1">
                  Target principal calculation:
                </div>
                <div className="font-mono text-xs space-y-1">
                  {currentAprPercent > 0 ? (
                    <>
                      <div>Monthly income × (12 / APR)</div>
                      <div>
                        {Math.round(p.targetMonthlyEGP).toLocaleString()} × (12
                        / {currentAprPercent}%) =
                      </div>
                      <div className="font-medium text-sm">
                        {Math.round(p.targetPrincipalEGP).toLocaleString()} EGP
                        required investment
                      </div>
                    </>
                  ) : (
                    <div className="text-muted-foreground">
                      Please set an APR to calculate required investment
                    </div>
                  )}
                </div>
              </div>
              <div>
                <span className="text-muted-foreground">
                  Current monthly interest (EGP):{" "}
                </span>
                <span className="font-medium">
                  {Math.round(p.currentMonthlyInterestEGP).toLocaleString()} EGP
                </span>
              </div>
              {p.monthsToTarget != null && (
                <div className="pt-2 border-t gaia-border">
                  <div>
                    <span className="text-muted-foreground">
                      Monthly deposit (EGP):{" "}
                    </span>
                    <span className="font-medium">
                      {Math.round(monthlyEgpContribution).toLocaleString()} EGP
                    </span>
                  </div>
                  <div>
                    <span className="text-muted-foreground">
                      Est. months to target:{" "}
                    </span>
                    <span className="font-medium">{monthsDisplay(p.monthsToTarget)}</span>
                  </div>
                  <div>
                    <span className="text-muted-foreground">
                      Est. final principal:{" "}
                    </span>
                    <span className="font-medium">
                      {(() => {
                        // Get the appropriate simulation result based on plan type
                        const sim =
                          p.type === "D"
                            ? planDSim
                            : p.type === "C"
                            ? planCSim
                            : p.type === "B"
                            ? planBSim
                            : planASim;

                        const finalPrincipal = sim?.principal;
                        return !finalPrincipal || !isFinite(finalPrincipal)
                          ? "—"
                          : Math.round(finalPrincipal).toLocaleString() +
                              " EGP";
                      })()}
                    </span>
                  </div>
                </div>
              )}
            </div>
            {/* Small simulator summary merged into each plan */}
            <div className="mt-4 p-3 rounded-md border gaia-border bg-[color-mix(in_srgb,var(--gaia-surface)_88%,transparent)]">
              <div className="text-sm mb-2">Simulator (quick):</div>
              <div className="grid grid-cols-1 sm:grid-cols-4 gap-2 text-sm">
                <div>
                  <div className="text-muted-foreground">Monthly deposit</div>
                  <div className="font-medium">
                    {Math.round(monthlyEgpContribution).toLocaleString()} EGP
                  </div>
                </div>
                <div>
                  <div className="text-muted-foreground">Current APR</div>
                  <div className="font-medium">{currentAprPercent}%</div>
                </div>
                <div>
                  <div className="text-muted-foreground">Est. months</div>
                    <div className="font-medium">{monthsDisplay(p.monthsToTarget)}</div>
                </div>
                <div>
                  <div className="text-muted-foreground">Est. principal</div>
                  <div className="font-medium">
                    {!p.estimatedPrincipal || !isFinite(p.estimatedPrincipal)
                      ? "—"
                      : Math.round(p.estimatedPrincipal).toLocaleString() +
                        " EGP"}
                  </div>
                </div>
              </div>
              <div className="mt-3 flex items-center gap-2">
                <button
                  className="px-3 py-1 rounded border gaia-border gaia-surface text-sm"
                  onClick={() => {
                    document
                      .getElementById("savings-simulator")
                      ?.scrollIntoView({ behavior: "smooth", block: "start" });
                  }}
                >
                  Open full simulator
                </button>
                <div className="text-xs text-muted-foreground">
                  Opens the full simulator below; adjust deposit values there.
                      {(() => {
                        const m = p.monthsToTarget;
                        if (m == null || !isFinite(m) || m <= 0) return "—";
                        if (m >= 1200) return "Not reachable";
                        if (m > 600) return "600+";
                        return String(Math.round(m));
                      })()}
  );
}
